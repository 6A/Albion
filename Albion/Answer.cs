using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Albion
{
    /// <summary>
    /// 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class Answer<T>
    {
        /// <summary>
        /// The description provided by <see cref="SentenceAttribute.Description"/> or <see cref="SentenceBuilder.Description(string)"/>.
        /// </summary>
        public string Description { get; private set; }
        /// <summary>
        /// The language of the matched sentence.
        /// </summary>
        public string Language { get; private set; }
        /// <summary>
        /// The ID provided by <see cref="SentenceAttribute.ID"/> or <see cref="SentenceBuilder.ID(string)"/>.
        /// </summary>
        public string ID { get; private set; }

        /// <summary>
        /// Whether this method should be called asynchronously.
        /// </summary>
        public bool IsAsync { get; private set; }
        /// <summary>
        /// The <see cref="Type"/> of the object returned by <see cref="Call()"/>.
        /// </summary>
        public Type ReturnType { get { return typeof(T); } }
        /// <summary>
        /// The <see cref="Type"/> of the class which defined the method to call.
        /// </summary>
        public Type ObjectType { get; private set; }

        internal MethodInfo Method { get; set; }
        internal object[] Parameters { get; set; }
        
        internal Func<dynamic, object> Handler { get; set; }

        internal Engine Owner { get; set; }

        internal Answer(Answer a)
        {
            Language = a.Language;
            Description = a.Description;
            ID = a.ID;

            IsAsync = a.IsAsync;
            Method = a.Method;
            Parameters = a.Parameters;
            ObjectType = a.ObjectType;
            Handler = a.Handler_2;
            Owner = a.Owner;
        }

        /// <summary>
        /// Call the method, trying to automagically resolve
        /// its instance if it isn't static.
        /// </summary>
        public T Call()
        {
            if (Owner == null)
                return Call(null);
            else
                return Call(Owner.InstanceFor(ObjectType));
        }

        /// <summary>
        /// Call the method asynchronously, trying to automagically resolve
        /// its instance if it isn't static.
        /// </summary>
        public async Task<T> CallAsync()
        {
            if (Owner == null)
                return await CallAsync(null);
            else
                return await CallAsync(Owner.InstanceFor(ObjectType));
        }

        /// <summary>
        /// Call the method.
        /// </summary>
        /// <param name="invoker">The object on which to invoke the method.</param>
        /// <returns></returns>
        public T Call(object invoker)
        {
            if (Handler != null)
                return (T)Handler(Parameters[0]);
            else if (ObjectType != null && invoker?.GetType() != ObjectType)
                throw new InvalidCastException();
            else if (IsAsync)
                return CallAsync(invoker).GetAwaiter().GetResult();
            else
                return (T)Method.Invoke(invoker, Parameters);
        }

        /// <summary>
        /// Call the method asynchronously.
        /// </summary>
        /// <param name="invoker">The object on which to invoke the method.</param>
        /// <returns></returns>
        public async Task<T> CallAsync(object invoker)
        {
            if (ObjectType != null && invoker?.GetType() != ObjectType)
                throw new InvalidCastException();
            else if (!IsAsync)
                return Call(invoker);
            else
                return await (Task<T>)Method.Invoke(invoker, Parameters);
        }
    }

    /// <summary>
    /// An Answer generated by <see cref="Engine.Ask(string)"/>.
    /// </summary>
    public class Answer
    {
        /// <summary>
        /// The description provided by <see cref="SentenceAttribute.Description"/> or <see cref="SentenceBuilder.Description(string)"/>.
        /// </summary>
        public string Description { get; private set; }
        /// <summary>
        /// The language of the matched sentence.
        /// </summary>
        public string Language { get; private set; }
        /// <summary>
        /// The ID provided by <see cref="SentenceAttribute.ID"/> or <see cref="SentenceBuilder.ID(string)"/>.
        /// </summary>
        public string ID { get; private set; }
        
        /// <summary>
        /// Whether this method should be called asynchronously.
        /// </summary>
        public bool IsAsync { get; private set; }
        /// <summary>
        /// The <see cref="Type"/> of the object returned by <see cref="Call()"/>.
        /// </summary>
        public Type ReturnType { get; private set; }
        /// <summary>
        /// The <see cref="Type"/> of the class which defined the method to call.
        /// </summary>
        public Type ObjectType { get; private set; }

        internal MethodInfo Method { get; set; }
        internal object[] Parameters { get; set; }

        internal Action<dynamic> Handler_1 { get; set; }
        internal Func<dynamic, object> Handler_2 { get; set; }

        internal Engine Owner { get; set; }

        internal Answer(Action<dynamic> handler, object parameter, string lang, string descr, string id, Engine en)
        {
            var method = handler.GetMethodInfo();

            Description = descr;
            ID = id;
            Language = lang;

            IsAsync = false;
            ReturnType = typeof(void);
            Method = method;
            Parameters = new object[] { parameter };
            ObjectType = null;
            Handler_1 = handler;
            Owner = en;
        }

        internal Answer(Func<dynamic, object> handler, object parameter, string lang, string descr, string id, Engine en)
        {
            var method = handler.GetMethodInfo();

            Description = descr;
            ID = id;
            Language = lang;

            IsAsync = false;
            ReturnType = method.ReturnType;
            Method = method;
            Parameters = new object[] { parameter };
            ObjectType = null;
            Handler_2 = handler;
            Owner = en;
        }

        internal Answer(MethodInfo method, object[] parameters, string lang, string descr, string id, Engine en)
        {
            Description = descr;
            ID = id;
            Language = lang;

            IsAsync = method.ReturnType.FullName.StartsWith("System.Threading.Tasks.Task`1");
            ReturnType = IsAsync ? method.ReturnType.GenericTypeArguments[0] : method.ReturnType;
            Method = method;
            Parameters = parameters;
            ObjectType = method.IsStatic ? null : method.DeclaringType;
            Owner = en;
        }
        
        /// <summary>
        /// Call the method, trying to automagically resolve
        /// its instance if it isn't static.
        /// </summary>
        public object Call()
        {
            if (Owner == null)
                return Call(null);
            else
                return Call(Owner.InstanceFor(ObjectType));
        }

        /// <summary>
        /// Call the method asynchronously, trying to automagically resolve
        /// its instance if it isn't static.
        /// </summary>
        public async Task<object> CallAsync()
        {
            if (Owner == null)
                return await CallAsync(null);
            else
                return await CallAsync(Owner.InstanceFor(ObjectType));
        }
        
        /// <summary>
        /// Call the method, trying to automagically resolve
        /// its instance if it isn't static.
        /// </summary>
        public T Call<T>()
        {
            if (Owner == null)
                return Call<T>(null);
            else
                return Call<T>(Owner.InstanceFor(ObjectType));
        }

        /// <summary>
        /// Call the method asynchronously, trying to automagically resolve
        /// its instance if it isn't static.
        /// </summary>
        public async Task<T> CallAsync<T>()
        {
            if (Owner == null)
                return await CallAsync<T>(null);
            else
                return await CallAsync<T>(Owner.InstanceFor(ObjectType));
        }

        /// <summary>
        /// Call the method, and cast the result to T.
        /// </summary>
        /// <param name="invoker">The object on which to invoke the method.</param>
        /// <returns></returns>
        /// <exception cref="InvalidCastException"></exception>
        public T Call<T>(object invoker)
        {
            if (Handler_2 != null && ReturnType == typeof(T))
                return (T)Handler_2(Parameters[0]);
            else if (Handler_1 != null || ObjectType != null && invoker?.GetType() != ObjectType)
                throw new InvalidCastException();
            else if (IsAsync)
                return CallAsync<T>(invoker).GetAwaiter().GetResult();
            else if (ReturnType != typeof(T))
                throw new InvalidCastException(String.Format("{0} cannot be converted to {1}", Method.ReturnType, typeof(T)));
            else
                return (T)Method.Invoke(invoker, Parameters);
        }

        /// <summary>
        /// Call the method.
        /// </summary>
        /// <param name="invoker">The object on which to invoke the method.</param>
        /// <returns></returns>
        /// <exception cref="InvalidCastException"></exception>
        public object Call(object invoker)
        {
            if (Handler_1 != null)
            {
                Handler_1(Parameters[0]);
                return null;
            }
            else if (Handler_2 != null)
                return Handler_2(Parameters[0]);
            else if (ObjectType != null && invoker?.GetType() != ObjectType)
                throw new InvalidCastException();
            else if (IsAsync)
                return CallAsync(invoker).GetAwaiter().GetResult();
            else
                return Method.Invoke(invoker, Parameters);
        }

        /// <summary>
        /// Call the method asynchronously, and cast the result to T.
        /// </summary>
        /// <param name="invoker">The object on which to invoke the method.</param>
        /// <returns></returns>
        /// <exception cref="InvalidCastException"></exception>
        public async Task<T> CallAsync<T>(object invoker)
        {
            if (ObjectType != null && invoker?.GetType() != ObjectType)
                throw new InvalidCastException();
            else if (!IsAsync)
                return Call<T>(invoker);
            else if (ReturnType != typeof(T))
                throw new InvalidCastException(String.Format("{0} cannot be converted to {1}", Method.ReturnType, typeof(T)));
            else
                return await (Task<T>)Method.Invoke(invoker, Parameters);
        }

        /// <summary>
        /// Call the method asynchronously.
        /// </summary>
        /// <param name="invoker">The object on which to invoke the method.</param>
        /// <returns></returns>
        /// <exception cref="InvalidCastException"></exception>
        public async Task<object> CallAsync(object invoker)
        {
            if (ObjectType != null && invoker?.GetType() != ObjectType)
                throw new InvalidCastException();
            else if (!IsAsync)
                return Call(invoker);
            else
                return await (Task<object>)Method.Invoke(invoker, Parameters);
        }
    }
}
